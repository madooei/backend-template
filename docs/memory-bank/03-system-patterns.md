# System Patterns

## Architecture Overview

The application follows a strict **6-layer architecture** pattern with **event-driven capabilities** that ensures clear separation of concerns and maintainability:

```plaintext
┌─────────────────┐
│ Routes Layer   │ ← HTTP route definitions and middleware application
├─────────────────┤
│ Controllers    │ ← HTTP request/response handling
├─────────────────┤
│ Middlewares    │ ← Cross-cutting concerns (auth, validation, errors)
├─────────────────┤
│ Services       │ ← Business logic and orchestration + Event Emission
├─────────────────┤
│ Repositories   │ ← Data access abstraction
├─────────────────┤
│ Models/Schemas │ ← Data structure and validation
└─────────────────┘

┌────────────────────┐
│   Event System    │ ← Real-time updates and event-driven architecture
│                   │
│ ┌────────────────┐ │
│ │ Event Emitter │ │ ← Central event hub
│ └────────────────┘ │
│ ┌────────────────┐ │
│ │ SSE Endpoint  │ │ ← Real-time client connections
│ └────────────────┘ │
└────────────────────┘
          ↑
     Event Flow
```

## Layer Responsibilities

### 1. Model Layer (`src/schemas/`)

- **Purpose**: Single source of truth for data structures and validation
- **Technology**: Zod schemas with TypeScript type inference
- **Pattern**: Schema-first design with automatic type generation
- **Key Files**: `*.schema.ts` files (e.g., `note.schema.ts`, `user.schemas.ts`)

**Schema Definition Guidelines**:

All types and schemas must be defined in `src/schemas` directory, following `entity-name.schema.ts` pattern. Each type must be defined using Zod schema and the typescript type must be inferred from the Zod schema. We should export both the schema and the type.

```typescript
import { z } from "zod";

export const noteSchema = z.object({
  id: z.string(), // Primary key for the Note record
  content: z.string(),
  createdAt: z.date().optional(), // Set by DB/service, present on retrieved entities
  updatedAt: z.date().optional(), // Set by DB/service, present on retrieved entities
});

export type NoteType = z.infer<typeof noteSchema>;
```

Place related types/schemas in the same file. For example, place Data Access Objects (DAO) schema and types in the same file:

```typescript
export const createNoteSchema = noteSchema
  .omit({
    id: true, // Will be generated by the service/system
    createdAt: true, // Will be set by the service/database
    updatedAt: true, // Will be set by the service/database
  })
  .extend({
    // Ensure 'content' is explicitly required as it's min(1) in base schema but omit might make it optional
    content: z.string().min(1, "Note content is required for creation."),
  });
export type CreateNoteType = z.infer<typeof createNoteSchema>;

// For updates, 'id' is typically part of the URL, not the body.
// The DTO should only contain fields that can be changed.
export const updateNoteSchema = noteSchema
  .omit({
    id: true,
    createdAt: true,
    updatedAt: true,
  })
  .partial(); // All fields become optional for updates
export type UpdateNotetype = z.infer<typeof updateNoteSchema>;
```

Place shared types/schema in `src/schemas/shared.schema.ts`. For example:

```typescript
// Base Query Parameters Schema
export const queryParamsSchema = z.object({
  search: z.string().optional(),
  sortBy: z.string().optional(),
  sortOrder: z.enum(["asc", "desc"]).optional(),
  page: z.coerce.number().int().positive().optional(),
  limit: z.coerce.number().int().positive().optional(),
});

export type QueryParamsType = z.infer<typeof queryParamsSchema>;
```

### 2. Repository Layer (`src/repositories/`)

- **Pattern**: Repository Pattern with interface segregation
- **Structure**: Interface definition + multiple implementations
- **Data Mapping**: Database-specific formats ↔ Domain models
- **Validation**: Parse data from DB using Zod schemas

**Key Pattern**:

```typescript
// Interface definition
export interface INoteRepository {
  create(note: CreateNoteType): Promise<NoteType>;
  findById(id: string): Promise<NoteType | null>;
  // ... other methods
}

// Implementation with data mapping
export class MockDbNoteRepository implements INoteRepository {
  private mapDocumentToEntity(doc: any): NoteType {
    return noteSchema.parse({
      id: doc._id?.toString() || doc.id,
      content: doc.content,
      createdAt: doc.createdAt,
      updatedAt: doc.updatedAt,
    });
  }
}
```

### 3. Service Layer (`src/services/`)

- **Purpose**: Business logic, authorization, and data orchestration
- **Dependencies**: Repository interfaces (injected)
- **Responsibilities**: Business rules, multi-repository operations, external API calls
- **Error Handling**: Throws domain-specific Error subclasses

**Key Patterns**:

```typescript
export class NoteService {
  constructor(private noteRepository: INoteRepository) {}

  async createNote(
    data: CreateNoteType,
    user: AuthenticatedUserContextType,
  ): Promise<NoteType> {
    // Business logic and validation
    // Authorization checks
    // Repository operations
    // Return domain objects
  }
}
```

### 4. Controller Layer (`src/controllers/`)

- **Purpose**: HTTP request/response handling
- **Pattern**: Thin controllers that delegate to services
- **Validation**: Uses pre-validated data from middleware
- **Error Mapping**: Converts service errors to HTTP exceptions

**Key Pattern**:

```typescript
export class NoteController {
  constructor(private noteService: NoteService) {}

  async createNote(c: Context<AppEnv>) {
    const validatedBody = c.var.validatedBody as CreateNoteType;
    const user = c.var.user;

    try {
      const note = await this.noteService.createNote(validatedBody, user);
      return c.json(note, 201);
    } catch (error) {
      // Error mapping to HTTP responses
    }
  }
}
```

### 5. Middleware Layer (`src/middlewares/`)

- **Purpose**: Cross-cutting concerns and request preprocessing
- **Types**: Authentication, validation, error handling, logging
- **Pattern**: Hono middleware with context modification

**Key Patterns**:

```typescript
// Validation middleware
export const validateBody = (schema: ZodSchema) => {
  return async (c: Context, next: Next) => {
    const result = schema.safeParse(await c.req.json());
    if (!result.success) {
      throw new BadRequestHTTPException({ message: "Validation failed" });
    }
    c.set("validatedBody", result.data);
    await next();
  };
};
```

### 6. Routes Layer (`src/routes/`)

- **Purpose**: HTTP route definitions and middleware application
- **Pattern**: Feature-based route modules
- **Organization**: One router per domain entity

**Key Pattern**:

```typescript
export function createNoteRoutes({
  noteController,
}: {
  noteController: NoteController;
}) {
  const router = new Hono<AppEnv>();

  router.post("/", authMiddleware, validateBody(createNoteSchema), (c) =>
    noteController.createNote(c),
  );

  return router;
}
```

## Critical Implementation Patterns

### Dependency Injection Pattern

- **Services**: Inject repository interfaces, not concrete implementations
- **Controllers**: Inject service instances
- **Routes**: Inject controller instances
- **Benefits**: Testability, flexibility, loose coupling

### Error Handling Strategy

- **Service Layer**: Throws Error subclasses (NotFoundError, UnauthorizedError, etc.)
- **Controller Layer**: Throws HTTPException subclasses
- **Global Handler**: Maps service errors to HTTP responses
- **Consistency**: Standardized error response format

### Validation Strategy

- **Schema Definition**: Single Zod schema per entity
- **DTO Generation**: Derived schemas for create/update operations
- **Middleware Validation**: Pre-validate requests before controllers
- **Repository Validation**: Parse data from database using schemas

### Authentication/Authorization Flow

1. **Auth Middleware**: Validates Bearer token with external service
2. **User Context**: Populates `c.var.user` with authenticated user info
3. **Service Authorization**: Fine-grained permission checks in business logic
4. **Role-Based Access**: Admin vs User role distinctions

### Testing Patterns

#### Testing Strategy

We follow a layered testing approach that aligns with our application architecture. Each layer should be tested in isolation by mocking its dependencies. This ensures that tests are focused, fast, and reliable.

##### 1. Middleware Tests (`tests/middlewares/`)

- Test authentication, error handling, and other middleware functions in isolation
- Mock the request context and next function
- Verify middleware behavior for both successful and error cases
- Example: Test `auth.middleware.ts` middleware by mocking the `AuthenticationService`

##### 2. Route Tests (`tests/routes/`)

- Focus on route configuration and middleware application
- Verify correct HTTP methods are mapped to controller methods
- Test route parameter validation
- Ensure proper middleware chaining
- Example: Test that `/notes/:id` routes are properly configured with authentication middleware

##### 3. Controller Tests (`tests/controllers/`)

- Mock the service layer dependencies
- Test request parsing and response formatting
- Verify correct status codes and response structures
- Test error handling and edge cases
- Example: Test `NoteController` by mocking `NoteService`

##### 4. Service Tests (`tests/services/`)

- Mock repository layer dependencies (use MockDB implementation)
- Test business logic in isolation
- Verify complex validations and data transformations
- Test service orchestration of multiple repository calls
- Example: Test `NoteService` by mocking `NoteRepository` (through `note.mockdb.repository.ts`)

##### 5. Repository Tests (`tests/repositories/`)

- Use a test database or in-memory database
- Test database operations and queries
- Verify data mapping between domain models and database structures
- Test error handling for database operations
- Example: Test `NoteRepository` with a test MongoDB instance or in-memory mock database

##### 6. Schema/Model Tests (`tests/schemas/`)

- Test Zod schema validations
- Verify type inference works correctly
- Test custom validation rules
- Example: Test `NoteSchema` validation rules

#### Testing Best Practices

1. **Test Organization**

   - Use descriptive test names that explain the behavior being tested
   - Group related tests using `describe` blocks
   - Use `beforeEach` and `afterEach` hooks for setup and cleanup
   - Keep tests focused and atomic

2. **Mocking**

   - Use Vitest's mocking capabilities to isolate layers
   - Create mock implementations of interfaces rather than concrete classes
   - Use `vi.mock()` for module-level mocking
   - Consider creating shared mock factories for common dependencies

3. **Test Data**

   - Use factory functions to create test data
   - Keep test data close to the tests that use it
   - Consider using a test database for repository tests
   - Clean up test data after each test

4. **Assertions**
   - Use specific assertions that test behavior, not implementation
   - Verify both happy paths and error cases
   - Test edge cases and boundary conditions
   - Use snapshot testing sparingly and only for complex objects

#### Coverage Requirements

- Aim for at least 90% code coverage
- Focus on critical business logic and error handling paths
- Use coverage reports to identify untested code paths
- Review coverage reports as part of the code review process

## File Naming Conventions

Files should follow this naming pattern to maintain consistency and readability across the project: `entity-name.type.ts`

- **`entity-name`**: The name of the primary entity or feature. For multiple words, use **kebab-case** (e.g., `course-registration`, `user-profile`).
- **`type`**: A suffix showing the file's role. Common types include `controller`, `service`, `repository`, `schema`, `middleware`, etc. Files of the same type should be stored together—for example, all `.schema.ts` files go in the `src/schema/` directory.

For general-purpose files like `app.ts` or `server.ts`, you can omit the "type".

### Specific Naming Patterns

- **Schemas**: `entity-name.schema.ts`
- **Repositories**: `entity-name.repository.ts` (interface), `entity-name.mockdb.repository.ts` (implementation)
- **Services**: `entity-name.service.ts`
- **Controllers**: `entity-name-controller.ts`
- **Routes**: `entity-name.router.ts`
- **Tests**: Mirror source structure with `.test.ts` suffix

## Directory Structure

```plaintext
.
├── dist
├── docker
├── docs
├── scripts
├── src
│   ├── controllers
│   ├── errors
│   ├── middlewares
│   ├── repositories
│   │   └── mockdb
│   ├── routes
│   ├── schemas
│   └── services
└── tests
```

## Import Patterns

Always use path aliases in import statements instead of relative paths.

- **Path Aliases**: Always use `@/` instead of relative paths (e.g., `import { app } from "@/app";`)
- **Barrel Exports**: Avoid; prefer explicit imports for clarity
- **Path Mapping**: `@/*` is mapped to `src/*`. All path aliases must be defined in both `tsconfig.json` and `tsup.config.ts`

## Environment and Configuration

### Environment Variables Guidelines

All environment variables must be defined and validated (through Zod) in the `src/env.ts` and imported from this file to other files.

When adding new environment variables, make sure to document them in `.env.example`.

- **Environment Variables**: Centralized in `src/env.ts` with Zod validation
- **Type Safety**: Environment variables are typed and validated at startup
- **Documentation**: All variables documented in `.env.example`
- **Import Pattern**: Always import environment variables from `src/env.ts`, never use `process.env` directly

## Event-Driven Architecture Patterns

### Event System Foundation (`src/events/`)

**Purpose**: Centralized event management for real-time updates and event-driven architecture education

**⚠️ Known Issues & Improvements Needed**:

- **ServiceEvent Interface**: Current interface includes resource-specific fields (`visibility`, `ownerId`) that don't work generically across different entity types
- **Authorization Pattern**: Permission logic should be moved from generic interface to resource-specific filtering functions
- **Planned Refactoring**: Make ServiceEvent generic with `id`, `resourceType` fields and optional `user` field for system events

#### Event Emitter Pattern

```typescript
// src/events/event-emitter.ts
import { EventEmitter } from "events";

export interface ServiceEvent<T = any> {
  action: "created" | "updated" | "deleted";
  data: T;
  id?: string | number;
  user?: { id: string; [key: string]: any };
  visibility?: "public" | "private" | "team";
  ownerId?: string;
  timestamp: Date;
}

class AppEventEmitter extends EventEmitter {
  emitServiceEvent<T>(serviceName: string, event: ServiceEvent<T>) {
    this.emit(`${serviceName}:${event.action}`, event);
  }
}

export const appEvents = new AppEventEmitter();
```

#### Base Service Pattern

```typescript
// src/events/base.service.ts
import { appEvents, ServiceEvent } from "./event-emitter";

export abstract class BaseService {
  constructor(protected serviceName: string) {}

  protected emitEvent<T>(
    action: ServiceEvent<T>["action"],
    data: T,
    options?: {
      id?: string | number;
      user?: any;
      visibility?: string;
      ownerId?: string;
    },
  ) {
    appEvents.emitServiceEvent(this.serviceName, {
      action,
      data,
      timestamp: new Date(),
      ...options,
    });
  }
}
```

#### Service Integration Pattern

```typescript
// Enhanced service with event emission
export class NoteService extends BaseService {
  constructor(noteRepository?: INoteRepository) {
    super("notes"); // Service name for events
    // ... existing constructor logic
  }

  async create(
    data: CreateNoteType,
    user: AuthenticatedUserContextType,
  ): Promise<NoteType> {
    // ... existing business logic
    const note = await this.noteRepository.create(data, user.userId);

    // Emit event after successful operation
    this.emitEvent("created", note, {
      id: note.id,
      user,
      visibility: "public", // All notes are public per requirements
    });

    return note;
  }
}
```

### Server-Sent Events (SSE) Pattern

#### SSE Endpoint Implementation

```typescript
// src/routes/events.router.ts
import { Hono } from "hono";
import { stream } from "hono/streaming";
import { appEvents } from "@/events/event-emitter";
import { authMiddleware } from "@/middlewares/auth.middleware";
import type { AppEnv } from "@/schemas/app-env.schema";

export function createEventsRoutes() {
  const router = new Hono<AppEnv>();

  router.get("/events", authMiddleware, async (c) => {
    const currentUser = c.var.user;

    return stream(c, async (stream) => {
      // Set SSE headers
      c.header("Content-Type", "text/event-stream");
      c.header("Cache-Control", "no-cache");
      c.header("Connection", "keep-alive");
      c.header("Access-Control-Allow-Origin", "*");

      const eventHandler = (event: any) => {
        if (shouldUserReceiveEvent(event, currentUser)) {
          stream.write(`event: notes:${event.action}\n`);
          stream.write(`data: ${JSON.stringify(event)}\n\n`);
        }
      };

      // Listen to all note events
      appEvents.on("notes:created", eventHandler);
      appEvents.on("notes:updated", eventHandler);
      appEvents.on("notes:deleted", eventHandler);

      // Keep connection alive
      const keepAlive = setInterval(() => {
        stream.write(": heartbeat\n\n");
      }, 30000);

      // Cleanup on disconnect
      stream.onAbort(() => {
        appEvents.off("notes:created", eventHandler);
        appEvents.off("notes:updated", eventHandler);
        appEvents.off("notes:deleted", eventHandler);
        clearInterval(keepAlive);
      });
    });
  });

  return router;
}

function shouldUserReceiveEvent(event: any, user: any): boolean {
  // For now, all notes are public, so all authenticated users get events
  return event.visibility === "public";
}
```

### Event Schema Patterns

```typescript
// src/schemas/event.schema.ts
import { z } from "zod";

export const serviceEventSchema = z.object({
  action: z.enum(["created", "updated", "deleted"]),
  data: z.any(), // Will be typed based on specific entity
  id: z.union([z.string(), z.number()]).optional(),
  user: z
    .object({
      id: z.string(),
    })
    .passthrough()
    .optional(),
  visibility: z.enum(["public", "private", "team"]).optional(),
  ownerId: z.string().optional(),
  timestamp: z.date(),
});

export type ServiceEventType = z.infer<typeof serviceEventSchema>;

// Specific event types
export const noteEventSchema = serviceEventSchema.extend({
  data: z.object({
    id: z.string(),
    content: z.string(),
    createdAt: z.date().optional(),
    updatedAt: z.date().optional(),
  }),
});

export type NoteEventType = z.infer<typeof noteEventSchema>;
```

### Event Testing Patterns

#### Event Emission Testing

```typescript
// tests/services/note.service.test.ts
import { vi } from "vitest";
import { appEvents } from "@/events/event-emitter";

describe("NoteService Event Emission", () => {
  it("should emit created event after successful note creation", async () => {
    const eventSpy = vi.spyOn(appEvents, "emitServiceEvent");

    const note = await noteService.create(validNoteData, mockUser);

    expect(eventSpy).toHaveBeenCalledWith("notes", {
      action: "created",
      data: note,
      id: note.id,
      user: mockUser,
      visibility: "public",
      timestamp: expect.any(Date),
    });
  });
});
```

#### SSE Endpoint Testing

```typescript
// tests/routes/events.router.test.ts
import { testClient } from "hono/testing";
import { appEvents } from "@/events/event-emitter";

describe("Events SSE Endpoint", () => {
  it("should stream events to authenticated clients", async () => {
    const app = createTestApp();
    const client = testClient(app);

    // Mock SSE connection
    const response = await client.events.$get({
      headers: { Authorization: "Bearer valid-token" },
    });

    // Emit test event
    appEvents.emitServiceEvent("notes", {
      action: "created",
      data: mockNote,
      visibility: "public",
      timestamp: new Date(),
    });

    // Verify event was streamed
    expect(response.status).toBe(200);
    expect(response.headers.get("content-type")).toBe("text/event-stream");
  });
});
```

### Event System Benefits

#### Educational Value

- **Event-Driven Architecture**: Students learn how to decouple systems using events
- **Real-time Communication**: Understanding of SSE vs WebSocket trade-offs
- **Observer Pattern**: Practical implementation of the observer design pattern
- **Scalability Concepts**: How events enable horizontal scaling

#### Technical Benefits

- **Loose Coupling**: Services don't need to know about real-time clients
- **Extensibility**: Easy to add new event types and listeners
- **Testing**: Events can be easily mocked and verified
- **Performance**: Efficient event distribution to multiple clients

#### Future Extensions

- **Event Persistence**: Store events for replay capabilities
- **Event Filtering**: Client-side subscription to specific event types
- **Event Batching**: Combine multiple rapid events to reduce noise
- **Cross-Service Events**: Events that span multiple microservices

## Development Workflow Patterns

- **Hot Reload**: `tsx watch` for development server
- **Debugging**: VS Code launch configurations for app and scripts
- **Testing**: Vitest with watch mode and coverage reporting
- **Code Quality**: ESLint + Prettier with pre-commit hooks
- **Containerization**: Docker development containers with VS Code integration
