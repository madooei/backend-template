# System Patterns

## Architecture Overview

The application follows a strict **6-layer architecture** pattern that ensures clear separation of concerns and maintainability:

```plaintext
┌─────────────────┐
│ Routes Layer   │ ← HTTP route definitions and middleware application
├─────────────────┤
│ Controllers    │ ← HTTP request/response handling
├─────────────────┤
│ Middlewares    │ ← Cross-cutting concerns (auth, validation, errors)
├─────────────────┤
│ Services       │ ← Business logic and orchestration
├─────────────────┤
│ Repositories   │ ← Data access abstraction
├─────────────────┤
│ Models/Schemas │ ← Data structure and validation
└─────────────────┘
```

## Layer Responsibilities

### 1. Model Layer (`src/schemas/`)

- **Purpose**: Single source of truth for data structures and validation
- **Technology**: Zod schemas with TypeScript type inference
- **Pattern**: Schema-first design with automatic type generation
- **Key Files**: `*.schema.ts` files (e.g., `note.schema.ts`, `user.schemas.ts`)

**Schema Definition Guidelines**:

All types and schemas must be defined in `src/schemas` directory, following `entity-name.schema.ts` pattern. Each type must be defined using Zod schema and the typescript type must be inferred from the Zod schema. We should export both the schema and the type.

```typescript
import { z } from "zod";

export const noteSchema = z.object({
  id: z.string(), // Primary key for the Note record
  content: z.string(),
  createdAt: z.date().optional(), // Set by DB/service, present on retrieved entities
  updatedAt: z.date().optional(), // Set by DB/service, present on retrieved entities
});

export type NoteType = z.infer<typeof noteSchema>;
```

Place related types/schemas in the same file. For example, place Data Access Objects (DAO) schema and types in the same file:

```typescript
export const createNoteSchema = noteSchema
  .omit({
    id: true, // Will be generated by the service/system
    createdAt: true, // Will be set by the service/database
    updatedAt: true, // Will be set by the service/database
  })
  .extend({
    // Ensure 'content' is explicitly required as it's min(1) in base schema but omit might make it optional
    content: z.string().min(1, "Note content is required for creation."),
  });
export type CreateNoteType = z.infer<typeof createNoteSchema>;

// For updates, 'id' is typically part of the URL, not the body.
// The DTO should only contain fields that can be changed.
export const updateNoteSchema = noteSchema
  .omit({
    id: true,
    createdAt: true,
    updatedAt: true,
  })
  .partial(); // All fields become optional for updates
export type UpdateNotetype = z.infer<typeof updateNoteSchema>;
```

Place shared types/schema in `src/schemas/shared.schema.ts`. For example:

```typescript
// Base Query Parameters Schema
export const queryParamsSchema = z.object({
  search: z.string().optional(),
  sortBy: z.string().optional(),
  sortOrder: z.enum(["asc", "desc"]).optional(),
  page: z.coerce.number().int().positive().optional(),
  limit: z.coerce.number().int().positive().optional(),
});

export type QueryParamsType = z.infer<typeof queryParamsSchema>;
```

### 2. Repository Layer (`src/repositories/`)

- **Pattern**: Repository Pattern with interface segregation
- **Structure**: Interface definition + multiple implementations
- **Data Mapping**: Database-specific formats ↔ Domain models
- **Validation**: Parse data from DB using Zod schemas

**Key Pattern**:

```typescript
// Interface definition
export interface INoteRepository {
  create(note: CreateNoteType): Promise<NoteType>;
  findById(id: string): Promise<NoteType | null>;
  // ... other methods
}

// Implementation with data mapping
export class MockDbNoteRepository implements INoteRepository {
  private mapDocumentToEntity(doc: any): NoteType {
    return noteSchema.parse({
      id: doc._id?.toString() || doc.id,
      content: doc.content,
      createdAt: doc.createdAt,
      updatedAt: doc.updatedAt,
    });
  }
}
```

### 3. Service Layer (`src/services/`)

- **Purpose**: Business logic, authorization, and data orchestration
- **Dependencies**: Repository interfaces (injected)
- **Responsibilities**: Business rules, multi-repository operations, external API calls
- **Error Handling**: Throws domain-specific Error subclasses

**Key Patterns**:

```typescript
export class NoteService {
  constructor(private noteRepository: INoteRepository) {}

  async createNote(
    data: CreateNoteType,
    user: AuthenticatedUserContextType,
  ): Promise<NoteType> {
    // Business logic and validation
    // Authorization checks
    // Repository operations
    // Return domain objects
  }
}
```

### 4. Controller Layer (`src/controllers/`)

- **Purpose**: HTTP request/response handling
- **Pattern**: Thin controllers that delegate to services
- **Validation**: Uses pre-validated data from middleware
- **Error Mapping**: Converts service errors to HTTP exceptions

**Key Pattern**:

```typescript
export class NoteController {
  constructor(private noteService: NoteService) {}

  async createNote(c: Context<AppEnv>) {
    const validatedBody = c.var.validatedBody as CreateNoteType;
    const user = c.var.user;

    try {
      const note = await this.noteService.createNote(validatedBody, user);
      return c.json(note, 201);
    } catch (error) {
      // Error mapping to HTTP responses
    }
  }
}
```

### 5. Middleware Layer (`src/middlewares/`)

- **Purpose**: Cross-cutting concerns and request preprocessing
- **Types**: Authentication, validation, error handling, logging
- **Pattern**: Hono middleware with context modification

**Key Patterns**:

```typescript
// Validation middleware
export const validateBody = (schema: ZodSchema) => {
  return async (c: Context, next: Next) => {
    const result = schema.safeParse(await c.req.json());
    if (!result.success) {
      throw new BadRequestHTTPException({ message: "Validation failed" });
    }
    c.set("validatedBody", result.data);
    await next();
  };
};
```

### 6. Routes Layer (`src/routes/`)

- **Purpose**: HTTP route definitions and middleware application
- **Pattern**: Feature-based route modules
- **Organization**: One router per domain entity

**Key Pattern**:

```typescript
export function createNoteRoutes({
  noteController,
}: {
  noteController: NoteController;
}) {
  const router = new Hono<AppEnv>();

  router.post("/", authMiddleware, validateBody(createNoteSchema), (c) =>
    noteController.createNote(c),
  );

  return router;
}
```

## Critical Implementation Patterns

### Dependency Injection Pattern

- **Services**: Inject repository interfaces, not concrete implementations
- **Controllers**: Inject service instances
- **Routes**: Inject controller instances
- **Benefits**: Testability, flexibility, loose coupling

### Error Handling Strategy

- **Service Layer**: Throws Error subclasses (NotFoundError, UnauthorizedError, etc.)
- **Controller Layer**: Throws HTTPException subclasses
- **Global Handler**: Maps service errors to HTTP responses
- **Consistency**: Standardized error response format

### Validation Strategy

- **Schema Definition**: Single Zod schema per entity
- **DTO Generation**: Derived schemas for create/update operations
- **Middleware Validation**: Pre-validate requests before controllers
- **Repository Validation**: Parse data from database using schemas

### Authentication/Authorization Flow

1. **Auth Middleware**: Validates Bearer token with external service
2. **User Context**: Populates `c.var.user` with authenticated user info
3. **Service Authorization**: Fine-grained permission checks in business logic
4. **Role-Based Access**: Admin vs User role distinctions

### Testing Patterns

#### Testing Strategy

We follow a layered testing approach that aligns with our application architecture. Each layer should be tested in isolation by mocking its dependencies. This ensures that tests are focused, fast, and reliable.

##### 1. Middleware Tests (`tests/middlewares/`)

- Test authentication, error handling, and other middleware functions in isolation
- Mock the request context and next function
- Verify middleware behavior for both successful and error cases
- Example: Test `auth.middleware.ts` middleware by mocking the `AuthenticationService`

##### 2. Route Tests (`tests/routes/`)

- Focus on route configuration and middleware application
- Verify correct HTTP methods are mapped to controller methods
- Test route parameter validation
- Ensure proper middleware chaining
- Example: Test that `/notes/:id` routes are properly configured with authentication middleware

##### 3. Controller Tests (`tests/controllers/`)

- Mock the service layer dependencies
- Test request parsing and response formatting
- Verify correct status codes and response structures
- Test error handling and edge cases
- Example: Test `NoteController` by mocking `NoteService`

##### 4. Service Tests (`tests/services/`)

- Mock repository layer dependencies (use MockDB implementation)
- Test business logic in isolation
- Verify complex validations and data transformations
- Test service orchestration of multiple repository calls
- Example: Test `NoteService` by mocking `NoteRepository` (through `note.mockdb.repository.ts`)

##### 5. Repository Tests (`tests/repositories/`)

- Use a test database or in-memory database
- Test database operations and queries
- Verify data mapping between domain models and database structures
- Test error handling for database operations
- Example: Test `NoteRepository` with a test MongoDB instance or in-memory mock database

##### 6. Schema/Model Tests (`tests/schemas/`)

- Test Zod schema validations
- Verify type inference works correctly
- Test custom validation rules
- Example: Test `NoteSchema` validation rules

#### Testing Best Practices

1. **Test Organization**

   - Use descriptive test names that explain the behavior being tested
   - Group related tests using `describe` blocks
   - Use `beforeEach` and `afterEach` hooks for setup and cleanup
   - Keep tests focused and atomic

2. **Mocking**

   - Use Vitest's mocking capabilities to isolate layers
   - Create mock implementations of interfaces rather than concrete classes
   - Use `vi.mock()` for module-level mocking
   - Consider creating shared mock factories for common dependencies

3. **Test Data**

   - Use factory functions to create test data
   - Keep test data close to the tests that use it
   - Consider using a test database for repository tests
   - Clean up test data after each test

4. **Assertions**
   - Use specific assertions that test behavior, not implementation
   - Verify both happy paths and error cases
   - Test edge cases and boundary conditions
   - Use snapshot testing sparingly and only for complex objects

#### Coverage Requirements

- Aim for at least 90% code coverage
- Focus on critical business logic and error handling paths
- Use coverage reports to identify untested code paths
- Review coverage reports as part of the code review process

## File Naming Conventions

Files should follow this naming pattern to maintain consistency and readability across the project: `entity-name.type.ts`

- **`entity-name`**: The name of the primary entity or feature. For multiple words, use **kebab-case** (e.g., `course-registration`, `user-profile`).
- **`type`**: A suffix showing the file's role. Common types include `controller`, `service`, `repository`, `schema`, `middleware`, etc. Files of the same type should be stored together—for example, all `.schema.ts` files go in the `src/schema/` directory.

For general-purpose files like `app.ts` or `server.ts`, you can omit the "type".

### Specific Naming Patterns

- **Schemas**: `entity-name.schema.ts`
- **Repositories**: `entity-name.repository.ts` (interface), `entity-name.mockdb.repository.ts` (implementation)
- **Services**: `entity-name.service.ts`
- **Controllers**: `entity-name-controller.ts`
- **Routes**: `entity-name.router.ts`
- **Tests**: Mirror source structure with `.test.ts` suffix

## Directory Structure

```plaintext
.
├── dist
├── docker
├── docs
├── scripts
├── src
│   ├── controllers
│   ├── errors
│   ├── middlewares
│   ├── repositories
│   │   └── mockdb
│   ├── routes
│   ├── schemas
│   └── services
└── tests
```

## Import Patterns

Always use path aliases in import statements instead of relative paths.

- **Path Aliases**: Always use `@/` instead of relative paths (e.g., `import { app } from "@/app.ts";`)
- **File Extensions**: Include `.ts` extension in imports
- **Barrel Exports**: Avoid; prefer explicit imports for clarity
- **Path Mapping**: `@/*` is mapped to `src/*`. All path aliases must be defined in both `tsconfig.json` and `tsup.config.ts`

## Environment and Configuration

### Environment Variables Guidelines

All environment variables must be defined and validated (through Zod) in the `src/env.ts` and imported from this file to other files.

When adding new environment variables, make sure to document them in `.env.example`.

- **Environment Variables**: Centralized in `src/env.ts` with Zod validation
- **Type Safety**: Environment variables are typed and validated at startup
- **Documentation**: All variables documented in `.env.example`
- **Import Pattern**: Always import environment variables from `src/env.ts`, never use `process.env` directly

## Development Workflow Patterns

- **Hot Reload**: `tsx watch` for development server
- **Debugging**: VS Code launch configurations for app and scripts
- **Testing**: Vitest with watch mode and coverage reporting
- **Code Quality**: ESLint + Prettier with pre-commit hooks
- **Containerization**: Docker development containers with VS Code integration
