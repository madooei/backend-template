# System Patterns

## Architecture Overview

The application follows a strict **6-layer architecture** pattern with **event-driven capabilities** that ensures clear separation of concerns and maintainability:

```plaintext
┌─────────────────┐
│ Routes Layer   │ ← HTTP route definitions and middleware application
├─────────────────┤
│ Controllers    │ ← HTTP request/response handling
├─────────────────┤
│ Middlewares    │ ← Cross-cutting concerns (auth, validation, errors)
├─────────────────┤
│ Services       │ ← Business logic and orchestration + Event Emission
├─────────────────┤
│ Repositories   │ ← Data access abstraction
├─────────────────┤
│ Models/Schemas │ ← Data structure and validation
└─────────────────┘

┌────────────────────┐
│   Event System    │ ← Real-time updates and event-driven architecture
│                   │
│ ┌────────────────┐ │
│ │ Event Emitter │ │ ← Central event hub
│ └────────────────┘ │
│ ┌────────────────┐ │
│ │ SSE Endpoint  │ │ ← Real-time client connections
│ └────────────────┘ │
└────────────────────┘
          ↑
     Event Flow
```

## Layer Responsibilities

### 1. Model Layer (`src/schemas/`)

- **Purpose**: Single source of truth for data structures and validation
- **Technology**: Zod schemas with TypeScript type inference
- **Pattern**: Schema-first design with automatic type generation
- **Key Files**: `*.schema.ts` files (e.g., `note.schema.ts`, `user.schemas.ts`)

**Schema Definition Guidelines**:

All types and schemas must be defined in `src/schemas` directory, following `entity-name.schema.ts` pattern. Each type must be defined using Zod schema and the typescript type must be inferred from the Zod schema. We should export both the schema and the type.

```typescript
import { z } from "zod";

export const noteSchema = z.object({
  id: z.string(), // Primary key for the Note record
  content: z.string(),
  createdAt: z.date().optional(), // Set by DB/service, present on retrieved entities
  updatedAt: z.date().optional(), // Set by DB/service, present on retrieved entities
});

export type NoteType = z.infer<typeof noteSchema>;
```

Place related types/schemas in the same file. For example, place Data Access Objects (DAO) schema and types in the same file:

```typescript
export const createNoteSchema = noteSchema
  .omit({
    id: true, // Will be generated by the service/system
    createdAt: true, // Will be set by the service/database
    updatedAt: true, // Will be set by the service/database
  })
  .extend({
    // Ensure 'content' is explicitly required as it's min(1) in base schema but omit might make it optional
    content: z.string().min(1, "Note content is required for creation."),
  });
export type CreateNoteType = z.infer<typeof createNoteSchema>;

// For updates, 'id' is typically part of the URL, not the body.
// The DTO should only contain fields that can be changed.
export const updateNoteSchema = noteSchema
  .omit({
    id: true,
    createdAt: true,
    updatedAt: true,
  })
  .partial(); // All fields become optional for updates
export type UpdateNoteType = z.infer<typeof updateNoteSchema>;
```

Place shared types/schema in `src/schemas/shared.schema.ts`. For example:

```typescript
// Base Query Parameters Schema
export const queryParamsSchema = z.object({
  search: z.string().optional(),
  sortBy: z.string().optional(),
  sortOrder: z.enum(["asc", "desc"]).optional(),
  page: z.coerce.number().int().positive().optional(),
  limit: z.coerce.number().int().positive().optional(),
});

export type QueryParamsType = z.infer<typeof queryParamsSchema>;
```

### 2. Repository Layer (`src/repositories/`)

- **Pattern**: Repository Pattern with interface segregation
- **Structure**: Interface definition + multiple implementations
- **Data Mapping**: Database-specific formats ↔ Domain models
- **Validation**: Parse data from DB using Zod schemas

**Key Pattern**:

```typescript
// Interface definition
export interface INoteRepository {
  create(note: CreateNoteType): Promise<NoteType>;
  findById(id: string): Promise<NoteType | null>;
  // ... other methods
}

// Implementation with data mapping
export class MockDbNoteRepository implements INoteRepository {
  private mapDocumentToEntity(doc: any): NoteType {
    return noteSchema.parse({
      id: doc._id?.toString() || doc.id,
      content: doc.content,
      createdAt: doc.createdAt,
      updatedAt: doc.updatedAt,
    });
  }
}
```

#### MongoDB Repository Implementation Patterns

**✅ Production Implementation**: `src/repositories/mongodb/note.mongodb.repository.ts`

**Key Design Decisions**:

- **Direct MongoDB Driver**: Uses `mongodb` package directly instead of Mongoose for educational transparency and custom repository control
- **Schema Validation**: Uses Zod schemas for data validation instead of MongoDB/Mongoose schemas, maintaining single source of truth
- **Document Mapping**: Clear separation between MongoDB documents and domain entities with explicit mapping functions
- **Lazy Collection Loading**: Collections are initialized on first use, not at instantiation time
- **Index Management**: Automatic index creation for performance optimization (idempotent operations)

**MongoDB-Specific Patterns**:

```typescript
// MongoDB document interface (internal to repository)
interface MongoNoteDocument extends Omit<NoteType, "id" | "createdAt" | "updatedAt"> {
  _id?: ObjectId;
  createdAt: Date;
  updatedAt: Date;
}

// Document to Entity mapping with Zod validation
private mapDocumentToEntity(doc: WithId<MongoNoteDocument>): NoteType {
  const { _id, ...restOfDoc } = doc;
  return noteSchema.parse({
    ...restOfDoc,
    id: _id.toHexString(), // Convert ObjectId to string
    createdAt: doc.createdAt,
    updatedAt: doc.updatedAt,
  });
}

// Entity to Document mapping for creation
private mapEntityToDocument(
  data: CreateNoteType,
  createdByUserId: UserIdType
): Omit<MongoNoteDocument, "_id"> {
  const now = new Date();
  return {
    content: data.content,
    createdBy: createdByUserId,
    createdAt: now,
    updatedAt: now,
  };
}
```

**Performance Optimization Patterns**:

```typescript
// Automatic index creation (idempotent)
private async createIndexes(collection: Collection<MongoNoteDocument>): Promise<void> {
  await Promise.all([
    collection.createIndex({ createdBy: 1 }, { name: "notes_createdBy" }),
    collection.createIndex({ createdAt: -1 }, { name: "notes_createdAt_desc" }),
    collection.createIndex({ content: "text" }, { name: "notes_content_text" }),
  ]);
}

// Efficient pagination and filtering
const [documents, total] = await Promise.all([
  collection.find(filter).sort(sort).skip(skip).limit(limit).toArray(),
  collection.countDocuments(filter),
]);
```

**Connection Management Pattern**:

```typescript
// Singleton database connection with graceful shutdown
class DatabaseConnection {
  private client: MongoClient | null = null;
  private db: Db | null = null;

  async connect(): Promise<Db> {
    if (this.db) return this.db;

    this.client = new MongoClient(MONGODB_URI);
    await this.client.connect();
    this.db = this.client.db(env.MONGODB_DATABASE);
    return this.db;
  }

  async disconnect(): Promise<void> {
    if (this.client) {
      await this.client.close();
      this.client = null;
      this.db = null;
    }
  }
}
```

### 3. Service Layer (`src/services/`)

- **Purpose**: Business logic, authorization, and data orchestration
- **Dependencies**: Repository interfaces (injected)
- **Responsibilities**: Business rules, multi-repository operations, external API calls
- **Error Handling**: Throws domain-specific Error subclasses

**Key Patterns**:

```typescript
export class NoteService {
  constructor(private noteRepository: INoteRepository) {}

  async createNote(
    data: CreateNoteType,
    user: AuthenticatedUserContextType,
  ): Promise<NoteType> {
    // Business logic and validation
    // Authorization checks
    // Repository operations
    // Return domain objects
  }
}
```

### 4. Controller Layer (`src/controllers/`)

- **Purpose**: HTTP request/response handling
- **Pattern**: Thin controllers that delegate to services
- **Validation**: Uses pre-validated data from middleware
- **Error Mapping**: Converts service errors to HTTP exceptions

**Key Pattern**:

```typescript
export class NoteController {
  constructor(private noteService: NoteService) {}

  async createNote(c: Context<AppEnv>) {
    const validatedBody = c.var.validatedBody as CreateNoteType;
    const user = c.var.user;

    try {
      const note = await this.noteService.createNote(validatedBody, user);
      return c.json(note, 201);
    } catch (error) {
      // Error mapping to HTTP responses
    }
  }
}
```

### 5. Middleware Layer (`src/middlewares/`)

- **Purpose**: Cross-cutting concerns and request preprocessing
- **Types**: Authentication, validation, error handling, logging
- **Pattern**: Hono middleware with context modification

**Key Patterns**:

```typescript
// Validation middleware
export const validateBody = (schema: ZodSchema) => {
  return async (c: Context, next: Next) => {
    const result = schema.safeParse(await c.req.json());
    if (!result.success) {
      throw new BadRequestHTTPException({ message: "Validation failed" });
    }
    c.set("validatedBody", result.data);
    await next();
  };
};
```

### 6. Routes Layer (`src/routes/`)

- **Purpose**: HTTP route definitions and middleware application
- **Pattern**: Feature-based route modules
- **Organization**: One router per domain entity

**Key Pattern**:

```typescript
export function createNoteRoutes({
  noteController,
}: {
  noteController: NoteController;
}) {
  const router = new Hono<AppEnv>();

  router.post("/", authMiddleware, validateBody(createNoteSchema), (c) =>
    noteController.createNote(c),
  );

  return router;
}
```

## Critical Implementation Patterns

### Dependency Injection Pattern

- **Services**: Inject repository interfaces, not concrete implementations
- **Controllers**: Inject service instances
- **Routes**: Inject controller instances
- **Benefits**: Testability, flexibility, loose coupling

### Error Handling Strategy

- **Service Layer**: Throws Error subclasses (NotFoundError, UnauthorizedError, etc.)
- **Controller Layer**: Throws HTTPException subclasses
- **Global Handler**: Maps service errors to HTTP responses
- **Consistency**: Standardized error response format

### Validation Strategy

- **Schema Definition**: Single Zod schema per entity
- **DTO Generation**: Derived schemas for create/update operations
- **Middleware Validation**: Pre-validate requests before controllers
- **Repository Validation**: Parse data from database using schemas

### Authentication/Authorization Flow

1. **Auth Middleware**: Validates Bearer token with external service
2. **User Context**: Populates `c.var.user` with authenticated user info
3. **Service Authorization**: Fine-grained permission checks in business logic
4. **Role-Based Access**: Admin vs User role distinctions

### Testing Patterns

#### Testing Strategy

We follow a layered testing approach that aligns with our application architecture. Each layer should be tested in isolation by mocking its dependencies. This ensures that tests are focused, fast, and reliable.

##### 1. Middleware Tests (`tests/middlewares/`)

- Test authentication, error handling, and other middleware functions in isolation
- Mock the request context and next function
- Verify middleware behavior for both successful and error cases
- Example: Test `auth.middleware.ts` middleware by mocking the `AuthenticationService`

##### 2. Route Tests (`tests/routes/`)

- Focus on route configuration and middleware application
- Verify correct HTTP methods are mapped to controller methods
- Test route parameter validation
- Ensure proper middleware chaining
- Example: Test that `/notes/:id` routes are properly configured with authentication middleware

##### 3. Controller Tests (`tests/controllers/`)

- Mock the service layer dependencies
- Test request parsing and response formatting
- Verify correct status codes and response structures
- Test error handling and edge cases
- Example: Test `NoteController` by mocking `NoteService`

##### 4. Service Tests (`tests/services/`)

- Mock repository layer dependencies (use MockDB implementation)
- Test business logic in isolation
- Verify complex validations and data transformations
- Test service orchestration of multiple repository calls
- Example: Test `NoteService` by mocking `NoteRepository` (through `note.mockdb.repository.ts`)

##### 5. Repository Tests (`tests/repositories/`)

- Use a test database or in-memory database
- Test database operations and queries
- Verify data mapping between domain models and database structures
- Test error handling for database operations
- Example: Test `NoteRepository` with a test MongoDB instance or in-memory mock database

##### 6. Schema/Model Tests (`tests/schemas/`)

- Test Zod schema validations
- Verify type inference works correctly
- Test custom validation rules
- Example: Test `NoteSchema` validation rules

#### Testing Best Practices

1. **Test Organization**
   - Use descriptive test names that explain the behavior being tested
   - Group related tests using `describe` blocks
   - Use `beforeEach` and `afterEach` hooks for setup and cleanup
   - Keep tests focused and atomic

2. **Mocking**
   - Use Vitest's mocking capabilities to isolate layers
   - Create mock implementations of interfaces rather than concrete classes
   - Use `vi.mock()` for module-level mocking
   - Consider creating shared mock factories for common dependencies

3. **Test Data**
   - Use factory functions to create test data
   - Keep test data close to the tests that use it
   - Consider using a test database for repository tests
   - Clean up test data after each test

4. **Assertions**
   - Use specific assertions that test behavior, not implementation
   - Verify both happy paths and error cases
   - Test edge cases and boundary conditions
   - Use snapshot testing sparingly and only for complex objects

#### Coverage Requirements

- Aim for at least 90% code coverage
- Focus on critical business logic and error handling paths
- Use coverage reports to identify untested code paths
- Review coverage reports as part of the code review process

## File Naming Conventions

Files should follow this naming pattern to maintain consistency and readability across the project: `entity-name.type.ts`

- **`entity-name`**: The name of the primary entity or feature. For multiple words, use **kebab-case** (e.g., `course-registration`, `user-profile`).
- **`type`**: A suffix showing the file's role. Common types include `controller`, `service`, `repository`, `schema`, `middleware`, etc. Files of the same type should be stored together—for example, all `.schema.ts` files go in the `src/schema/` directory.

For general-purpose files like `app.ts` or `server.ts`, you can omit the "type".

### Resource Naming Convention

**Critical Rule**: Use **singular** for domain entities/resources, **plural** for cross-cutting concerns:

- **Domain Entities** (singular): `note.schema.ts`, `note.service.ts`, `note.controller.ts`, `note.router.ts`
- **Cross-cutting Concerns** (plural): `events.router.ts` (handles events across all resources)
- **Utility Services** (descriptive): `authentication.service.ts`, `authorization.service.ts`

### Specific Naming Patterns

- **Schemas**: `entity-name.schema.ts` (singular entity)
- **Repositories**: `entity-name.repository.ts` (interface), `entity-name.mockdb.repository.ts` (implementation)
- **Services**: `entity-name.service.ts` (singular entity) or `descriptive-name.service.ts` (utility services)
- **Controllers**: `entity-name.controller.ts` (singular entity)
- **Routes**: `entity-name.router.ts` (singular entity) or `cross-cutting-concern.router.ts` (plural for cross-cutting)
- **Tests**: Mirror source structure with `.test.ts` suffix

### Examples

**✅ Correct Domain Entity Naming:**

```
note.schema.ts
note.service.ts
note.controller.ts
note.router.ts
note.repository.ts
```

**✅ Correct Cross-cutting Concern Naming:**

```
events.router.ts          // Handles events across all resources
metrics.router.ts         // Would handle metrics across all resources
health.router.ts          // Would handle health checks across all resources
```

**✅ Correct Utility Service Naming:**

```
authentication.service.ts // Authentication logic
authorization.service.ts  // Authorization logic
email.service.ts          // Email sending logic
```

**❌ Incorrect Naming:**

```
notes.schema.ts           // Should be note.schema.ts (singular)
event.router.ts           // Should be events.router.ts (cross-cutting concern)
auth.service.ts           // Should be authentication.service.ts (descriptive)
```

## Directory Structure

```plaintext
.
├── dist
├── docker
├── docs
├── scripts
├── src
│   ├── controllers
│   ├── events
│   ├── errors
│   ├── middlewares
│   ├── repositories
│   │   └── mockdb
│   ├── routes
│   ├── schemas
│   └── services
└── tests
```

## Import Patterns

Always use path aliases in import statements instead of relative paths.

- **Path Aliases**: Always use `@/` instead of relative paths (e.g., `import { app } from "@/app";`)
- **Barrel Exports**: Avoid; prefer explicit imports for clarity
- **Path Mapping**: `@/*` is mapped to `src/*`. All path aliases must be defined in both `tsconfig.json` and `tsup.config.ts`

## Environment and Configuration

### Environment Variables Guidelines

All environment variables must be defined and validated (through Zod) in the `src/env.ts` and imported from this file to other files.

When adding new environment variables, make sure to document them in `.env.example`.

- **Environment Variables**: Centralized in `src/env.ts` with Zod validation
- **Type Safety**: Environment variables are typed and validated at startup
- **Documentation**: All variables documented in `.env.example`
- **Import Pattern**: Always import environment variables from `src/env.ts`, never use `process.env` directly

## Event-Driven Architecture Patterns

### Event System Foundation (`src/events/`)

**Purpose**: Centralized event management for real-time updates and event-driven architecture education

**✅ Implementation Status**: Complete and Production Ready

**Key Design Decisions**:

- **Generic Event Schema**: Uses `data: z.unknown()` for type flexibility across different entity types
- **ReadableStream API**: Modern streaming approach with proper connection management
- **Resource-based Authorization**: Event filtering follows same rules as CRUD permissions
- **Educational Architecture**: Complete event-driven pattern demonstration for student learning

**Documentation**: Comprehensive implementation guide available in `docs/guides/server-sent-events.md`

#### Event Emitter Pattern

```typescript
// src/events/event-emitter.ts
import { EventEmitter } from "events";
import type { ServiceEventType } from "@/schemas/event.schema";

class AppEventEmitter extends EventEmitter {
  emitServiceEvent(serviceName: string, event: ServiceEventType) {
    this.emit(`${serviceName}:${event.action}`, event);
  }
}

export const appEvents = new AppEventEmitter();
```

#### Base Service Pattern

```typescript
// src/events/base.service.ts
import { appEvents } from "./event-emitter";
import type { ServiceEventType } from "@/schemas/event.schema";
import { v4 as uuidv4 } from "uuid";

export abstract class BaseService {
  constructor(protected serviceName: string) {}

  protected emitEvent<T>(
    action: ServiceEventType["action"],
    data: T,
    options?: {
      id?: string;
      user?: { userId: string; [key: string]: unknown };
    },
  ) {
    const eventUser = options?.user
      ? {
          id: options.user.userId,
          ...options.user,
        }
      : undefined;

    appEvents.emitServiceEvent(this.serviceName, {
      id: options?.id || uuidv4(),
      action,
      data,
      user: eventUser,
      timestamp: new Date(),
      resourceType: this.serviceName,
    });
  }
}
```

#### Service Integration Pattern

```typescript
// Enhanced service with event emission
export class NoteService extends BaseService {
  constructor(noteRepository?: INoteRepository) {
    super("notes"); // Service name for events
    // ... existing constructor logic
  }

  async create(
    data: CreateNoteType,
    user: AuthenticatedUserContextType,
  ): Promise<NoteType> {
    // ... existing business logic
    const note = await this.noteRepository.create(data, user.userId);

    // Emit event after successful operation
    this.emitEvent("created", note, {
      id: note.id,
      user,
    });

    return note;
  }
}
```

### Server-Sent Events (SSE) Pattern

#### SSE Endpoint Implementation

```typescript
// src/routes/events.router.ts
import { Hono } from "hono";
import { appEvents } from "@/events/event-emitter";
import { authMiddleware } from "@/middlewares/auth.middleware";
import { AuthorizationService } from "@/services/authorization.service";
import type { AppEnv } from "@/schemas/app-env.schema";
import type { ServiceEventType } from "@/schemas/event.schema";
import type { AuthenticatedUserContextType } from "@/schemas/user.schemas";

export function createEventsRoutes() {
  const router = new Hono<AppEnv>();

  router.get("/events", authMiddleware, async (c) => {
    const currentUser = c.var.user;
    if (!currentUser) {
      return c.text("Unauthorized", 401);
    }

    const authorizationService = new AuthorizationService();

    // Return a Response with a ReadableStream
    const readable = new ReadableStream({
      start(controller) {
        // Send initial connection message
        controller.enqueue(
          new TextEncoder().encode(`data: {"type":"connected"}\n\n`),
        );

        const eventHandler = async (event: ServiceEventType) => {
          try {
            const canReceive = await shouldUserReceiveEvent(
              event,
              currentUser,
              authorizationService,
            );
            if (canReceive) {
              const eventData = `event: notes:${event.action}\ndata: ${JSON.stringify(event)}\n\n`;
              controller.enqueue(new TextEncoder().encode(eventData));
            }
          } catch (error: unknown) {
            console.error("Error in event handler:", error);
          }
        };

        // Listen to all note events
        appEvents.on("notes:created", eventHandler);
        appEvents.on("notes:updated", eventHandler);
        appEvents.on("notes:deleted", eventHandler);

        // Keep connection alive with heartbeat
        const keepAlive = setInterval(() => {
          try {
            controller.enqueue(new TextEncoder().encode(": heartbeat\n\n"));
          } catch (error: unknown) {
            console.error("Heartbeat error:", error);
            clearInterval(keepAlive);
          }
        }, 30000);

        // Store cleanup function
        (controller as any).cleanup = () => {
          appEvents.off("notes:created", eventHandler);
          appEvents.off("notes:updated", eventHandler);
          appEvents.off("notes:deleted", eventHandler);
          clearInterval(keepAlive);
        };
      },
      cancel(controller) {
        // Cleanup when client disconnects
        if ((controller as any).cleanup) {
          (controller as any).cleanup();
        }
      },
    });

    // Set SSE headers directly on the Response object
    return new Response(readable, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
      },
    });
  });

  return router;
}

async function shouldUserReceiveEvent(
  event: ServiceEventType,
  user: AuthenticatedUserContextType,
  authorizationService: AuthorizationService,
): Promise<boolean> {
  // Resource-specific authorization logic using AuthorizationService
  switch (event.resourceType) {
    case "notes":
      // Ensure event.data has the required structure for note events
      if (
        typeof event.data === "object" &&
        event.data !== null &&
        "createdBy" in event.data
      ) {
        return await authorizationService.canReceiveNoteEvent(
          user,
          event.data as { createdBy: string; [key: string]: unknown },
        );
      }
      return false;
    default:
      // Unknown resource types are not allowed
      return false;
  }
}
```

### Event Schema Patterns

```typescript
// src/schemas/event.schema.ts
import { z } from "zod";

export const serviceEventSchema = z.object({
  id: z.string(), // Event's own ID for storage/audit
  action: z.enum(["created", "updated", "deleted"]),
  data: z.unknown(), // Will be typed based on specific entity
  user: z
    .object({
      id: z.string(),
    })
    .passthrough()
    .optional(), // Optional for system events
  timestamp: z.date(), // When event occurred
  resourceType: z.string(), // 'notes', 'users', 'projects', etc.
});

export type ServiceEventType = z.infer<typeof serviceEventSchema>;

// Specific event types
export const noteEventSchema = serviceEventSchema.extend({
  data: z.object({
    id: z.string(),
    content: z.string(),
    createdAt: z.date().optional(),
    updatedAt: z.date().optional(),
  }),
});

export type NoteEventType = z.infer<typeof noteEventSchema>;
```

### Event Testing Patterns

#### Event Emission Testing

```typescript
// tests/services/note.service.test.ts
import { vi } from "vitest";
import { appEvents } from "@/events/event-emitter";

describe("NoteService Event Emission", () => {
  it("should emit created event after successful note creation", async () => {
    const eventSpy = vi.spyOn(appEvents, "emitServiceEvent");

    const note = await noteService.create(validNoteData, mockUser);

    expect(eventSpy).toHaveBeenCalledWith("notes", {
      id: expect.any(String),
      action: "created",
      data: note,
      user: {
        id: mockUser.userId,
        ...mockUser,
      },
      timestamp: expect.any(Date),
      resourceType: "notes",
    });
  });
});
```

#### SSE Endpoint Testing

```typescript
// tests/routes/events.router.test.ts
import { testClient } from "hono/testing";
import { appEvents } from "@/events/event-emitter";

describe("Events SSE Endpoint", () => {
  it("should stream events to authenticated clients", async () => {
    const app = createTestApp();
    const client = testClient(app);

    // Mock SSE connection
    const response = await client.events.$get({
      headers: { Authorization: "Bearer valid-token" },
    });

    // Emit test event
    appEvents.emitServiceEvent("notes", {
      id: "event-123",
      action: "created",
      data: mockNote,
      user: { id: "user-123" },
      timestamp: new Date(),
      resourceType: "notes",
    });

    // Verify event was streamed
    expect(response.status).toBe(200);
    expect(response.headers.get("content-type")).toBe("text/event-stream");
  });
});
```

### Event System Benefits

#### Educational Value

- **Event-Driven Architecture**: Students learn how to decouple systems using events
- **Real-time Communication**: Understanding of SSE vs WebSocket trade-offs
- **Observer Pattern**: Practical implementation of the observer design pattern
- **Scalability Concepts**: How events enable horizontal scaling

#### Technical Benefits

- **Loose Coupling**: Services don't need to know about real-time clients
- **Extensibility**: Easy to add new event types and listeners
- **Testing**: Events can be easily mocked and verified
- **Performance**: Efficient event distribution to multiple clients

#### Future Extensions

- **Event Persistence**: Store events for replay capabilities
- **Event Filtering**: Client-side subscription to specific event types
- **Event Batching**: Combine multiple rapid events to reduce noise
- **Cross-Service Events**: Events that span multiple microservices

## Development Workflow Patterns

- **Hot Reload**: `tsx watch` for development server
- **Debugging**: VS Code launch configurations for app and scripts
- **Testing**: Vitest with watch mode and coverage reporting
- **Code Quality**: ESLint + Prettier with pre-commit hooks
- **Containerization**: Docker development containers with VS Code integration
