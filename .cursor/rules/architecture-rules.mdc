---
description: 
globs: 
alwaysApply: true
---
This codebase follows a layered architecture. When implementing new features or updating existing ones, respect the following layers and their boundaries.

## 1. The Model Layer (Zod Schemas & TypeScript Types)

- **Location:** `src/schemas/`
- **Primary Role:** Defines the canonical shape and validation rules for all data structures within the application.
- **Responsibilities:**
    - Define Zod schemas for core domain entities (e.g., `Note`).
    - Define Data Transfer Object (DTO) schemas for request/response bodies (e.g., `CreateNote`, `UpdateNote`).
    - Define schemas for query parameters (e.g., `NoteQueryParams`).
    - Serve as the single source of truth for data validation logic (including type coercion, required fields, enums, and string formats).
    - Enable automatic TypeScript type inference from schemas (`z.infer<typeof schemaName>`).
- **Used By:** All other layers (Controllers, Services, Repositories) for data consistency and validation.
- **Key Principle:** If it concerns data structure, type, or basic validation rules, it belongs here.

## 2. The Data Access Layer (Interfaces and Implementations following the Repository Pattern)

- **Location:** `src/repositories/`
- **Primary Role:** Abstracts all database interactions, providing a clean API for the Service layer to handle data persistence and retrieval.
- **Responsibilities (Repository Interfaces - `src/repositories/`):**
    1. Define the contract (methods, parameters, return types) for data operations on a specific entity (e.g., `INoteRepository`).
    2. Use domain model types (from `src/schemas/`) in their method signatures.
- **Responsibilities (Repository Implementations - e.g., `src/repositories/mockdb/`, `src/repositories/mongodb/`):**
    1. Implement the corresponding repository interface using a specific database technology (e.g., `MockDbNoteRepository`, `MongoDbNoteRepository`).
    2. Contain all database-specific query logic and connection handling (via an injected DB instance or manager like `MongoDbDatabase`).
    3. **Data Mapping:** Map data between the database-specific format (e.g., MongoDB documents with `_id: ObjectId`) and the application's domain models (e.g., `Note` with `id: string`).
    4. **Validate Data Read from DB:** When mapping data *from* the database *to* a domain model (e.g., with a `mapDocumentToEntity` function), use the Zod schema's `.parse()` method. This ensures data integrity and protects against schema drift or database corruption.
    5. **Always Implement Mocks:** Implement an in-memory version of each repository interface as a mock database in `src/repositories/mockdb/`.
- **Does NOT Do:**
    - Contain business logic or business rule validation (this belongs in Services).
    - Perform authorization checks (this belongs in Services).
    - Validate the shape/type of DTOs or domain objects passed *to it* by the Service layer. The repository assumes that data has been validated by higher layers according to business rules.
- **Key Principle:** Repositories act as data access gateways, isolating database concerns and ensuring data conformity to defined models.

## 3. The Service Layer

- **Location:** `src/services/`
- **Primary Role:** Encapsulates business logic, orchestrates data operations, and enforces application rules.
- **Responsibilities:**
    1. **Business Logic Implementation:** Contains core logic for all use cases and operations (e.g., creating notes, accepting share invites).
    2. **Fine-Grained Authorization:** Performs permission checks using `UserContext` and resource-specific data. This includes checking ownership and roles (e.g., note author). An `AuthorizationService` centralizes this logic for other services.
    3. **Business Rule Validation:** Enforces complex validation rules beyond basic data validation (e.g., email uniqueness, verification code expiration, course capacity checks).
    4. **Data Orchestration & Integrity:** Uses repository interfaces to fetch and persist data. Manages operations requiring multiple data sources (e.g., verifying `userId` and `courseId` before creating a `Membership`).
    5. **External Service Integration:** Manages external API calls through dedicated client modules (e.g., syncing rosters with Canvas LMS).
    6. **Transaction Management:** Handles atomic operations across multiple database writes when native database support isn't available.
    7. **Return Values:** Returns domain objects from `src/schemas/` or business errors that controllers map to HTTP responses.
- **Service-to-Service Communication:**
    - Allowed when completing user-initiated operations that require multiple services.
    - The calling service passes `UserContext` to the called service.
    - Called services perform task-specific authorization without repeating top-level permission checks.
- **Key Principle:** Services act as the application's brain, managing business rules, validations, data access, and integrations.

## The Controller Layer

- **Location:** `src/controllers/`
- **Primary Role:** Serves as the interface between HTTP requests/responses and the application's business logic (Service Layer).
- **Responsibilities:**
    1. **HTTP Interaction:** Parses incoming HTTP requests (path parameters, query strings, request bodies).
    2. **Request Validation:** Uses dedicated validation middleware (`src/middlewares/validation.ts`) configured in `src/app.ts` with Zod DTOs/schemas from `src/schemas/`. This middleware validates incoming request data structure and types. Failed validation triggers an `HTTPException` (typically 400) before reaching the controller. Controllers access pre-validated data through `c.var` (e.g., `c.var.validatedBody`, `c.var.validatedQuery`).
    3. **User Context:** Accesses `UserContext` (set by `authMiddleware` in `c.var.user`) and passes it to the Service layer for authorization and attribution.
    4. **Delegation:** Calls one primary Service layer method to handle the business operation, passing pre-validated data, path parameters, and `UserContext`.
    5. **Response Formatting:** Formats HTTP responses based on Service layer output using `c.json(data, statusCode)` for success or maps service errors to appropriate `HTTPException` instances.
- **Does NOT Do:**
    - Handle complex business logic or rule validation (Services' responsibility)
    - Interact directly with repositories (Services' responsibility)
    - Perform detailed resource-based authorization (Services handle this, often via `AuthorizationService`)
    - Orchestrate multiple service calls (complex operations belong in a service method)
    - Call external APIs or third-party services directly (Services' responsibility)
- **Key Principle:** Controllers should remain lightweight and focused on HTTP handling. They act as traffic directors and translators, using middleware for basic validation while delegating business decisions to services.